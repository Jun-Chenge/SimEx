diff --git a/Sources/python/SimEx/Calculators/EMCOrientation.py b/Sources/python/SimEx/Calculators/EMCOrientation.py
index bbc8186..c482413 100644
--- a/Sources/python/SimEx/Calculators/EMCOrientation.py
+++ b/Sources/python/SimEx/Calculators/EMCOrientation.py
@@ -47,10 +47,11 @@ class EMCOrientation(AbstractPhotonAnalyzer):
     """
     Class representing photon data analysis for orientation of 2D diffraction patterns to a 3D diffraction volume. """
     def save(self,fname):
+        ### Doc missing. This function might also be used by users to generate snapshots etc. if not meant to expose, make private (__save)
         dill.dump(self, open(fname, "w"))
+
     def __init__(self, parameters=None, input_path=None, output_path=None, tmp_files_path=None, run_files_path=None):
         """
-
         :param  parameters: Parameters for the EMC orientation calculator.
         :type parameters: EMCOrientationParameters instance
 
@@ -196,19 +197,25 @@ class EMCOrientation(AbstractPhotonAnalyzer):
         return run_instance_dir, tmp_out_dir
 
     def parallel_backengine(self):
-
+        ### Doc missing. Do we have to expose both "backengine" and "parallel_backengine" to user or can we hide one? if one can be hidden, call that one __backengine, the other one backengine().
+        ### How much can we put into the abstract calculators? at least make a virtual method there to force
+        ### implementers of new calculators to add the method in the concrete class.
         fname=__name__+"_tmpobj"
         self.save(fname)
         command_sequence = ['mpirun',
-                            '-np', '1',
-                            'python', __file__,fname,
+                            '-np',
+                            '1', # I guess this will be set according to env. variables, later.
+                            'python',
+                            __file__,
+                            fname,
                             ]
         proc = subprocess.Popen(command_sequence,universal_newlines=True)
         proc.wait()
         os.remove(fname)
 
-    # Return the return code from the backengine.
+        # Return the return code from the backengine.
         return proc.returncode
+
     def backengine(self):
 
         status = self._run_emc()
@@ -448,8 +455,12 @@ def _checkPaths(run_files_path, tmp_files_path):
     return True
 
 if __name__ == '__main__':
+
+    # Add checks if file exists, throw exception if not with explanatory message.
+    #
+    # consider using argparse module.
     fname = sys.argv[1]
-    t = dill.load(open(fname))
-    status = t.backengine()
+    tempoary_object = dill.load(open(fname))
+    status = tempoary_object.backengine()
     sys.exit(status)
 
diff --git a/Sources/python/SimEx/Calculators/S2EReconstruction.py b/Sources/python/SimEx/Calculators/S2EReconstruction.py
index ba5276e..6a78b8f 100644
--- a/Sources/python/SimEx/Calculators/S2EReconstruction.py
+++ b/Sources/python/SimEx/Calculators/S2EReconstruction.py
@@ -137,6 +137,8 @@ class S2EReconstruction(AbstractPhotonAnalyzer):
         emc_status = self.__emc.parallel_backengine()
 
         # If EMC was not successful, return with error code.
+
+        ### don't debug print in production code.
         print emc_status
         if  emc_status!= 0:
             return emc_status
